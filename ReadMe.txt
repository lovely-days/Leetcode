
1.两数之和
    my solution
        使用双层循环对数组内各元素逐对进行尝试
            时间复杂度为 O(n*n),空间复杂度为 O(1)
    
    top solution
        使用散列表替代内层循环匹配，随循环将未命中元素逐一添加至散列表
            时间复杂度降为 O(n*1),利用额外散列表空间，最坏可达到 O(n)


2.两数相加
    my solution NewNode
        创建新链表存储计算后数值，输入链表不被破坏
        在运算中依次对两链表重合部分 (min(m,n)),剩余链表部分进行处理，使用数值变量标识进位
        时间复杂度为 O(max(m,n)),空间复杂度为 O(max(m,n))

    my solution ExistNode
        直接使用函数第一个链表参数储存计算后数值，输入链表被破坏
        运算方法同上
        时间复杂度为 O(max(m,n)),空间复杂度为 O(1)

    top solution
        采用递归方法解决，实现简洁，空间开销极大
        两数值相加和进位操作分离，在迭代相加返回时进行进位
        时间复杂度为 O(max(m,n)),空间复杂度为 O(max(m.n)) (新建链表) (此外有较大栈空间开支)

##  注意：
        在算法中应首先判断输入两链表是否为空，为空应直接返回
        可通过添加头结点方法简化算法


19.删除链表的倒数第 n 个结点
    my solution
        采用两个相隔 n 个结点的指针，从左至右逐个遍历，
        当右侧指针到达链表尾部时，左侧指针指向链表倒数第 n+1 个结点，从而删除链表倒数第 n 个结点
        时间复杂度为 O(n),空间复杂度为 O(1)
    
    top solution
        与 my solution 基本一致

##  注意：
        对于无头结点链表删除添加等操作，可以构建头结点以实现其操作统一
        对于两个链表指针命名可以采用 fast slow 


20.有效的括号
    my solution
        利用栈进行匹配
        采用 if 语句实现

**  注意：
        可利用哈希表进行匹配

21.合并两个有序链表
    my solution NewNode
        创建新链表存储合并后链表。
        对于两链表，逐一比较链表元素，将较小元素添加至新链表末端
        时间复杂度为 O(m+n),空间复杂度为 O(m+n)

    my solution ExistNode
        直接将输入第一个链表参数作为最终链表，
        将另一链表元素逐一与该链表元素比较，插入至合适的位置
        时间复杂度为 O(m+n),空间复杂度为 O(n) 
        

    my solution recursion
        递归算法，使用新链表存储合并后结果
        比较两链表当前元素大小，将小者插入最终链表，递归求解
        时间复杂度为 O(m+n),空间复杂度为 O(m+n)

    top solution
        递归算法，基于交换实现，不需要创建结点
        将第一个链表元素与第二个链表元素比较，若第一个链表为空或小于第二个链表元素值则交换两结点地址
        逐层推进
        时间复杂度为 O(m+n),空间复杂度为 O(1) (不考虑栈空间等)

##  注意：
        通过添加头结点以实现算法简化，同样适用于题 2.两数相加 
        指针实质为地址，可通过交换结点指针（地址）方式交换结点
        使用交换方式不创建结点，从而提高速度，减少所需空间


23.合并k个升序链表
    good recursion
        对题21中递归算法改进，直接使用原链表结点
        时间复杂度为 O(N),空间复杂度为 O(1)

    my solution
        对该k个升序链表逐一进行合并，共合并k次。合并时采用 good recursion 算法
        时间复杂度为 O(k*N),空间复杂度为 O(1)
    
    good solution
        采用分治法对该k个链表进行处理，合并次数减少为log(k)次
        时间复杂度降至为 O(N*log(k)),空间复杂度为 O(1)

**  other
        采用优先队列实现，

##  注意：
        分治大法好


24.两两交换链表中结点
    my solution
        直接利用结点指针调整指向关系即可
        时间复杂度为 O(N),空间复杂度为 O(1)

**  top solution
        没看懂，先丢这了

25.k个一组翻转链表
    my solution
        依托 题92.反转链表II 实现
        首先循环得出链表长度，此后对每一组需翻转结点调用翻转函数即可求解
        时间复杂度为 O(N),空间复杂度为 O(k)
        对于 题92.反转链表II中三种算法，单指针方法效果最好，递归方法最差

    top solution
        与 my solution 类似，将翻转函数在循环内部实现
        时间及空间复杂度与 my solution 一致

28.实现strStr()
    my solution KMP
        即完成模式匹配过程，原串及模式串均从 0 开始存储
        采用KMP算法实现，next数组长为串长+1，从 -1，0 开始
        时间复杂度为 O(N+M),空间复杂度为 O(N)

    my solution KMP pro
        KMP 算法改进版，修改 next 数组计算方法，减少相同元素比较次数，进一步减少回溯

**  注意：
        对于size_type(无符号数)和int(有符号数)注意主动转换
        否则将有符号数转换为无符号数使得负数部分大于正数部分

61.旋转链表
    my solution
        使用数组旋转方法，通过三次链表逆转以实现数组右移
        逆转算法依托 题92.反转链表II 实现
        时间复杂度为 O(N),空间复杂度为 O(1)

    top solution
        直接将链表尾结点连接至首结点以构建循环链表
        移动指示结点，在满足要求结点处将链表断开即可完成旋转操作
        仅需遍历链表两次，时间复杂度为 O(N),空间复杂度为 O(1)

##  注意：
        旋转链表与旋转数组不同，由于链表元素在移动时只需改变结点相对位置
        故可采用构建循环链表待到链表指针移动至指定位置再断开的方法进行链表旋转

83.删除排序链表中的重复元素
    my solution iteration
        迭代解法，采用双指针推进求解
        时间复杂度为 O(N),空间复杂度为 O(1)

    my solution recursion
        递归解法
        时间复杂度为 O(N),空间复杂度为 O(1) (不计栈空间消耗)

92.反转链表 II
    my solution iteration
        迭代方法
        使用两个指针分别指向起始结点前驱结点和终止结点后继结点，逐一将前指针后结点移动至后指针前以完成逆转
        时间复杂度为 O(N),空间复杂度为 O(1)

    my solution recursion
        递归方法
        首先将问题转换为逆转head指针后n个结点
        再利用递归方法逐一转换
        时间复杂度为 O(N),空间复杂度为 O(1) (不计栈空间消耗)

    top solution
        迭代方法，类似于my solution
        只使用起始结点处指针，通过不断将指针后元素插入起始结点指针后以实现逆转
        时间复杂度为 O(N),空间复杂度为 O(1)

##  注意：
    递归方法的使用
    递归应关注当前结点而不去代入整个递归过程
    对于递归函数应明确递归函数作用，返回值等，以实现递归

104.二叉树的最大深度
    my solution
        采用递归方法解决
        任何一结点的深度即等于其左右子结点深度最大值加 1
        时间复杂度为 O(N),空间复杂度为 O(1)


203.移除链表元素
    my solution iteration
        迭代方法
        通过设置头结点简化操作
        时间复杂度为 O(N),空间复杂度为 O(1)

    my solution recursion
        递归方法
        时间复杂度为 O(N),空间复杂度为 O(1) (不计栈空间消耗)


206.反转链表
    my solution iteration
        迭代方法，利用新结点实现
        时间复杂度为 O(N),空间复杂度为 O(N)

    my solution recursion
        递归方法，直接利用原结点
        时间复杂度为 O(N),空间复杂度为 O(1) (不计栈空间消耗)


222.完全二叉树结点的个数
    my_solution
        直接利用遍历实现
        时间复杂度为 O(N),空间复杂度为 O(N) (栈空间)

**  未考虑利用完全二叉树性质实现


237.删除链表中的结点
    my solution
        本题非常有趣，由于未给出前驱结点，无法直接删除
        故在此使用后一结点值替代当前结点，转而删除后一结点
        去其值而留其点


859.亲密字符串
    my solution
        共有三种不同情况
            (1)两字符串长度不同，必不可能是亲密字符串
            (2)两字符串相同，判断 A 中是否有相同字符，有则为亲密字符串
            (3)两字符串不同，有且仅有一次交换
        
**  在第二步中有许多不同解法
        (1) 散列表 时间复杂度为O(N),空间复杂度为O(N)
        (2) sort() unique() 时间复杂度为O(N*logN),空间复杂度为O(N)
        (3) 数组模拟散列表，与散列表方法一致


860.柠檬水找零
    my solution
        模拟+贪心算法
        贪心算法即指优先找面额较大钞票，生活常识
        时间复杂度为 O(N),空间复杂度为 O(1)


