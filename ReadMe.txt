
1.两数之和
    my solution
        使用双层循环对数组内各元素逐对进行尝试
            时间复杂度为 O(n*n),空间复杂度为 O(1)
    
    top solution
        使用散列表替代内层循环匹配，随循环将未命中元素逐一添加至散列表
            时间复杂度降为 O(n*1),利用额外散列表空间，最坏可达到 O(n)


2.两数相加
    my solution NewNode
        创建新链表存储计算后数值，输入链表不被破坏
        在运算中依次对两链表重合部分 (min(m,n)),剩余链表部分进行处理，使用数值变量标识进位
        时间复杂度为 O(max(m,n)),空间复杂度为 O(max(m,n))

    my solution ExistNode
        直接使用函数第一个链表参数储存计算后数值，输入链表被破坏
        运算方法同上
        时间复杂度为 O(max(m,n)),空间复杂度为 O(1)

    top solution
        采用递归方法解决，实现简洁，空间开销极大
        两数值相加和进位操作分离，在迭代相加返回时进行进位
        时间复杂度为 O(max(m,n)),空间复杂度为 O(max(m.n)) (新建链表) (此外有较大栈空间开支)

##  注意：
        在算法中应首先判断输入两链表是否为空，为空应直接返回
        可通过添加头结点方法简化算法


19.删除链表的倒数第 n 个结点
    my solution
        采用两个相隔 n 个结点的指针，从左至右逐个遍历，
        当右侧指针到达链表尾部时，左侧指针指向链表倒数第 n+1 个结点，从而删除链表倒数第 n 个结点
        时间复杂度为 O(n),空间复杂度为 O(1)
    
    top solution
        与 my solution 基本一致

##  注意：
        对于无头结点链表删除添加等操作，可以构建头结点以实现其操作统一
        对于两个链表指针命名可以采用 fast slow 


21.合并两个有序链表
    my solution NewNode
        创建新链表存储合并后链表。
        对于两链表，逐一比较链表元素，将较小元素添加至新链表末端
        时间复杂度为 O(m+n),空间复杂度为 O(m+n)

    my solution ExistNode
        直接将输入第一个链表参数作为最终链表，
        将另一链表元素逐一与该链表元素比较，插入至合适的位置
        时间复杂度为 O(m+n),空间复杂度为 O(n) 
        

    my solution recursion
        递归算法，使用新链表存储合并后结果
        比较两链表当前元素大小，将小者插入最终链表，递归求解
        时间复杂度为 O(m+n),空间复杂度为 O(m+n)

    top solution
        递归算法，基于交换实现，不需要创建结点
        将第一个链表元素与第二个链表元素比较，若第一个链表为空或小于第二个链表元素值则交换两结点地址
        逐层推进
        时间复杂度为 O(m+n),空间复杂度为 O(1) (不考虑栈空间等)

##  注意：
        通过添加头结点以实现算法简化，同样适用于题 2.两数相加 
        指针实质为地址，可通过交换结点指针（地址）方式交换结点
        使用交换方式不创建结点，从而提高速度，减少所需空间


23.合并k个升序链表
    good recursion
        对题21中递归算法改进，直接使用原链表结点
        时间复杂度为 O(N),空间复杂度为 O(1)

    my solution
        对该k个升序链表逐一进行合并，共合并k次。合并时采用 good recursion 算法
        时间复杂度为 O(k*N),空间复杂度为 O(1)
    
    good solution
        采用分治法对该k个链表进行处理，合并次数减少为log(k)次
        时间复杂度降至为 O(N*log(k)),空间复杂度为 O(1)

**  other
        采用优先队列实现，

##  注意：
        分治大法好


24.两两交换链表中结点
    my solution
        直接利用结点指针调整指向关系即可
        时间复杂度为 O(N),空间复杂度为 O(1)

**  top solution
        没看懂，先丢这了


203.移除链表元素
    my solution iteration
    迭代方法
    通过设置头结点简化操作
    时间复杂度为 O(N),空间复杂度为 O(1)

    my solution recursion
    递归方法
    时间复杂度为 O(N),空间复杂度为 O(1) (栈空间消耗不计)


206.反转链表
    my solution iteration
    迭代方法，利用新结点实现
    时间复杂度为 O(N),空间复杂度为 O(N)

    my solution recursion
    递归方法，直接利用原结点
    时间复杂度为 O(N),空间复杂度为 O(1) (栈空间消耗不计)





